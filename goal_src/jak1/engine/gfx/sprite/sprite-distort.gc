;;-*-Lisp-*-
(in-package goal)

;; name: sprite-distort.gc
;; name in dgo: sprite-distort
;; dgos: GAME, ENGINE

;; The sprite-distort is a VU1 renderer.
;; It likely does some of the effects with sprites.

;; Scratch information used by the sprite-distorter.
(deftype sprite-distorter-sine-tables (basic)
  ((aspx   float                  :offset-assert   4)
   (aspy   float                  :offset-assert   8)
   (entry  vector     128 :inline :offset-assert  16)
   (ientry qword      9 :inline   :offset-assert 2064)
   (giftag gs-gif-tag :inline     :offset-assert 2208)
   (color  qword      :inline     :offset-assert 2224)
   )
  :method-count-assert 9
  :size-assert         #x8c0
  :flag-assert         #x9000008c0
  )

(define *sprite-distorter-sine-tables* (new 'global 'sprite-distorter-sine-tables))

(defun sprite-distorter-generate-tables ()
  "Regenerate sprite-distorter tables.  This should be done whenever the aspect ratio changes"
  (let ((tables *sprite-distorter-sine-tables*))
    (let ((entry-index 0)
          (ientry-index 0)
          (iterations 3)
          ;; get camera aspect
          (cam-aspx (- (-> *math-camera* perspective vector 0 x)))
          (cam-aspy (- (-> *math-camera* perspective vector 1 y)))
          )
      ;; regenerate if aspect ratio changed
      (when (or (!= cam-aspx (-> tables aspx)) (!= cam-aspy (-> tables aspy)))
        (set! (-> tables aspx) cam-aspx)
        (set! (-> tables aspy) cam-aspy)
        (while (< iterations 12)
          ;; set ientry
          (set! (-> tables ientry ientry-index vector4w x) (+ entry-index 352)) ;; 352 = tables.entry in VU
          (+! ientry-index 1)
          ;; set entries
          (dotimes (i iterations)
            (let ((f26-0 (* 65536.0 (/ (the float i) (the float iterations)))))
              (set-vector!
               (-> tables entry entry-index)
               (* (sin f26-0) cam-aspx)
               (* (cos f26-0) cam-aspy)
               0.0
               0.0
               )
              (set-vector!
                (-> tables entry (+ entry-index 1))
                (* (* 0.001953125 cam-aspx) (sin f26-0))
                (* (* 0.00390625 cam-aspy) (cos f26-0))
                0.0
                0.0
                )
              (+! entry-index 2)
              )
            )
          (+! iterations 1)
          )
        ;; final entry pair
        (set-vector! (-> tables entry entry-index) 0.0 cam-aspy 0.0 0.0)
        (let ((v1-17 (+ entry-index 1)))
          (set-vector! (-> tables entry v1-17) 0.0 (* 0.00390625 cam-aspy) 0.0 0.0)
          (+ v1-17 1) ;; ?
          )
        )
      )
    ;; set up giftag
    (set! (-> tables giftag tag)
          (new 'static 'gif-tag64
               :nloop 1
               :eop 1
               :pre 1
               :prim (new 'static 'gs-prim :prim (gs-prim-type tri-strip) :tme 1)
               :nreg 15
               )
          )
    ;; set up registers
    (set! (-> tables giftag regs)
          (new 'static 'gif-tag-regs
               :regs0 (gif-reg-id st)
               :regs1 (gif-reg-id rgbaq)
               :regs2 (gif-reg-id xyzf2)
               :regs3 (gif-reg-id st)
               :regs4 (gif-reg-id rgbaq)
               :regs5 (gif-reg-id xyzf2)
               :regs6 (gif-reg-id st)
               :regs7 (gif-reg-id rgbaq)
               :regs8 (gif-reg-id xyzf2)
               :regs9 (gif-reg-id st)
               :regs10 (gif-reg-id rgbaq)
               :regs11 (gif-reg-id xyzf2)
               :regs12 (gif-reg-id st)
               :regs13 (gif-reg-id rgbaq)
               :regs14 (gif-reg-id xyzf2)
               )
          )
    ;; set color
    (set! (-> tables color vector4w x) 128)
    (set! (-> tables color vector4w y) 128)
    (set! (-> tables color vector4w z) 128)
    (set! (-> tables color vector4w w) 128)
    )
  0
  (none)
  )


;; we need to at least put something here so dma-buffer-add-vu-function doesn't crash.
(define sprite-distort-vu1-block (new 'static 'vu-function))


(defun sprite-init-distorter ((dma-buff dma-buffer) (frame-base-pointer uint))
  "Set up DMA for setting up the sprite-distorter renderer"
  ;;(format #t "distorter: ~d~%" (-> *sprite-aux-list* entry))
  
  ;; set up GS registers
  (dma-buffer-add-gs-set dma-buff
    ;; dont update zbuffer
    (zbuf-1 (new 'static 'gs-zbuf :zbp #x1c0 :psm (gs-psm ct24) :zmsk 1))
    ;; use framebuffer as texture
    (tex0-1 (new 'static 'gs-tex0 :tbw #x8 :tw #x9 :th #x8 :tbp0 (* frame-base-pointer 32)))
    ;; bilinear filtering
    (tex1-1 (new 'static 'gs-tex1 :mmag 1 :mmin 1))
    ;; mipmapping
    (miptbp1-1 (new 'static 'gs-miptbp))
    ;; set texture wrap mode to clamp
    (clamp-1
      (new 'static 'gs-clamp
          :wms (gs-tex-wrap-mode region-clamp)
          :wmt (gs-tex-wrap-mode region-clamp)
          :maxu #x1ff
          :maxv (-> *video-parms* screen-masky)
          )
      )
    ;; blend source and framebuffer RGB
    (alpha-1 (new 'static 'gs-alpha :b 1 :d 1))
    )
  ;; send current aspect used by the sine tables (PC only)
  (#when PC_PORT
    (let ((packet (the-as dma-packet (-> dma-buff base))))
      (set! (-> packet dma) (new 'static 'dma-tag :id (dma-tag-id cnt) :qwc 1))
      (set! (-> packet vif0) (new 'static 'vif-tag))
      (set! (-> packet vif1) (new 'static 'vif-tag :cmd (vif-cmd pc-port)))
      (&+! (-> dma-buff base) 16)
      )
    (let ((aspect-vec (the-as vector (-> dma-buff base))))
      (set-vector! aspect-vec 
                   (-> *sprite-distorter-sine-tables* aspx) 
                   (-> *sprite-distorter-sine-tables* aspy)
                   0.0
                   0.0
                   )
      (&+! (-> dma-buff base) 16)
      )
    )
  ;; send distorter sine tables
  (dma-buffer-add-ref-vif2 dma-buff #x8b
    (-> *sprite-distorter-sine-tables* entry)
    (new 'static 'vif-tag :imm #x404 :cmd (vif-cmd stcycl))
    (new 'static 'vif-tag :imm #x160 :num #x8b :cmd (vif-cmd unpack-v4-32))
    )
  ;; load VU1 code
  (dma-buffer-add-vu-function dma-buff sprite-distort-vu1-block 1)
  0
  (none)
  )

(defun sprite-draw-distorters2 ((dma-buff dma-buffer))
  "Set up DMA for the sprite-distorter renderer"
  
  (let ((dma-chunk-start (-> dma-buff base)) ;; s0-0 DMA start of current chunk
        (chunk-size 0) ;; s4-0 Number sprites in current chunk
        (sprite-count 0) ;; s5-0 Number of sprites for current draw
        )
    (&+! (-> dma-buff base) 16) ;; inc dma by 1 qw (leave room for potential vif header)

    ;; process each distort sprite
    (dotimes (i (-> *sprite-aux-list* entry))
      ;; process and add DMA for sprite
      (let* ((sprite (-> *sprite-aux-list* data i)) ;; sv-16
             (dma-position (the-as vector (&+ (-> dma-buff base) 0))) ;; a0-1
             (dma-st-flag (the-as vector (&+ (-> dma-buff base) 16))) ;; sv-32
             (dma-color (the-as vector (&+ (-> dma-buff base) 32))) ;; sv-48
             (cam-matrix (the-as matrix #f)) ;; vf3, vf4, vf5, vf6
             (cam-hvdf (the-as vector #f)) ;; vf9
             (cam-hmge-scale (-> *math-camera* hmge-scale)) ;; vf8
             (position (new 'stack-no-clear 'vector))
             (color (new 'stack-no-clear 'vector))
             (s-coord 0.0)
             (t-coord 0.0)
             )
        ;; skip sprite if it specifies zero turns
        (when-goto (zero? (-> sprite flag)) skip-sprite)
        ;; choose camera matrix and offset
        (cond
          ((= (-> sprite matrix) 1)
            (set! cam-matrix (-> *math-camera* sprite-2d))
            (set! cam-hvdf (-> *math-camera* sprite-2d-hvdf))
            )
          (else
            (set! cam-matrix (-> *math-camera* camera-temp))
            (set! cam-hvdf (-> *math-camera* hvdf-off))
            )
          )
        ;; load position and color into temporaries
        (set! (-> position quad) (-> sprite x-y-z-sx quad))
        (set! (-> color quad) (-> sprite color quad))
        ;; transform position to screen coordinates
        (transform-vector! position position cam-matrix)
        ;; clipping
        (let ((clip 0)) 
          (rlet ((Q :class vf)
                (vf0 :class vf)
                (vf1 :class vf)
                (vf2 :class vf)
                (vf3 :class vf)
                )
            (init-vf0-vector)
            (.lvf vf1 position)
            (.lvf vf2 cam-hmge-scale)
            (.mul.vf vf3 vf1 vf2)
            (set! clip (vu-clip vf3 0)) ;; safe to just drop the higher bits.
            )
          (when-goto (logtest? clip #b111111) skip-sprite)
          )
        ;; apply camera scale
        (let ((scale (/ 1.0 (-> cam-hmge-scale w))))
          (vector3s*float! position position scale)
          (vector3s*float! color color scale)
          )
        ;; apply camera offset
        (vector3s+! position position cam-hvdf)
        ;; clamp w
        ;; redundant? (.max.x.vf vf1 vf1 vf0 :mask #b1000)
        ;; (if (< 0.0 (-> position w))
        ;;   (set! (-> position w) 0.0)
        ;;   )
        ;; set w to 255.0
        (set! (-> position w) 255.0)
        ;; calculate ST coordinates
        ;; 0.001953125 = 1 / 512
        ;; 0.00390625 = 1 / 256
        (set! s-coord (* 0.001953125 (+ -1792.0 (-> position x))))
        (set! t-coord 
              (* 0.00390625
                 (+ (+ -2048.0 (-> *video-parms* screen-hy))
                    (-> position y)
                    )
                 )
              )
        ;; ensure number of turns is valid
        (when (or (< (-> sprite flag) 3) (< 11 (-> sprite flag)))
            (format 0 "Turns = ~D!!!~%" (-> sprite flag))
            (set! (-> sprite flag) 11)
            )
        ;; do stuff with color
        ;; TODO
        ;; store values in DMA chain
        (set! (-> dma-position quad) (-> position quad))
        (set-vector! dma-st-flag
                     s-coord
                     t-coord
                     1.0
                     (the-as int32 (-> sprite flag))
                     )
        (set! (-> dma-color quad) (-> color quad))
        (&+! (-> dma-buff base) 48)
        )
      
      ;; add sprite to chunk
      (+! chunk-size 1)

      ;; TODO: create packet for chunk if full

      (label skip-sprite)
      )
    )

  (none)
  )

(defun sprite-draw-distorters ((arg0 dma-buffer))
  "Set up DMA for the sprite-distorter renderer"
  (local-vars
   (v1-25 int)
   (sv-16 sprite-vec-data-2d)
   (sv-32 pointer)
   (sv-48 pointer)
   )
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf10 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf8 :class vf)
         (vf9 :class vf)
         )
    (init-vf0-vector)
    (.lvf vf8 (&-> *math-camera* hmge-scale quad))
    (let ((s0-0 (-> arg0 base))
          (s4-0 0)
          (s5-0 0)
          )
      ;; dma sprites in chunks
      (&+! (-> arg0 base) 16)
      (let* ((s3-0 *sprite-aux-list*)
             (s2-0 (-> s3-0 entry))
             )
        (dotimes (s1-0 s2-0)
          ;; get sprite
          (set! sv-16 (-> s3-0 data s1-0))

          (let ((a0-1 (the-as object (-> arg0 base))))
            (set! sv-32 (&+ (the-as pointer a0-1) 16))
            (set! sv-48 (&+ (the-as pointer a0-1) 32))
            (cond
              ((= (-> sv-16 matrix) 1)
               (.lvf vf3 (&-> *math-camera* sprite-2d vector 0 quad))
               (.lvf vf4 (&-> *math-camera* sprite-2d vector 1 quad))
               (.lvf vf5 (&-> *math-camera* sprite-2d vector 2 quad))
               (.lvf vf6 (&-> *math-camera* sprite-2d vector 3 quad))
               (.lvf vf9 (&-> *math-camera* sprite-2d-hvdf quad))
               )
              (else
               (.lvf vf3 (&-> *math-camera* camera-temp vector 0 quad))
               (.lvf vf4 (&-> *math-camera* camera-temp vector 1 quad))
               (.lvf vf5 (&-> *math-camera* camera-temp vector 2 quad))
               (.lvf vf6 (&-> *math-camera* camera-temp vector 3 quad))
               (.lvf vf9 (&-> *math-camera* hvdf-off quad))
               )
              )
            (.lvf vf1 (&-> sv-16 x-y-z-sx quad))
            (.lvf vf2 (&-> sv-16 color quad))
            ;; transform vec by matrix
            (.mul.w.vf acc vf6 vf0) ;; acc = vf6
            (.add.mul.x.vf acc vf3 vf1 acc) ;; acc = (vf3 * vf1.x) + acc
            (.add.mul.y.vf acc vf4 vf1 acc) ;; acc = (vf4 * vf1.y) + acc
            (.add.mul.z.vf vf1 vf5 vf1 acc) ;; vf1 = (vf5 * vf1.z) + acc
            ;; apply scale to position
            (.mul.vf vf10 vf1 vf8)
            ;; Q = 1 / vf10.w
            (.div.vf Q vf0 vf10 :fsf #b11 :ftf #b11)
            ;;(TODO.VCLIP vf10 vf10)
            ;; skip if flag is zero
            (b! (zero? (-> sv-16 flag)) cfg-21)
            ;; check for floating point exceptions
            (.wait.vf)
            ;; scale position xyz and color xyz by Q
            (.mul.vf vf1 vf1 Q :mask #b111)
            (.mul.vf vf2 vf2 Q :mask #b111)
            ;;(.cfc2.i v1-25 Clipping)
            ;; skip if sprite position if off screen?
            (set! v1-25 (vu-clip vf10 0)) ;; safe to just drop the higher bits.
            ;; also add camera offset
            (b! (logtest? v1-25 63) cfg-21 :delay (.add.vf vf1 vf1 vf9))
            ;; vf1.w = max(vf1.w, vf0.x)
            (.max.x.vf vf1 vf1 vf0 :mask #b1000)
            ;; place position and color into DMA
            (.svf (&-> (the-as vector a0-1) quad) vf1)
            (.svf (&-> (the-as vector sv-48) quad) vf2)
            ;; set position W to 255.0
            (set! (-> (the-as vector a0-1) w) 255.0)
            ;; set ST coords in DMA
            (set! (-> (the-as (pointer float) sv-32)) (* 0.001953125 (+ -1792.0 (-> (the-as vector a0-1) x))))
            (set! (-> (the-as vector sv-32) y)
                  (* 0.00390625
                     (+ (+ -2048.0 (the float (-> *video-parms* screen-hy)))
                        (-> (the-as vector a0-1) y)
                        )
                     )
                  )
            )
          (set! (-> (the-as vector sv-32) z) 1.0)
          ;; default flag if invalid (aka. turns, aka. 'resolution')
          (when (or (< (-> sv-16 flag) 3) (< 11 (-> sv-16 flag)))
            (format 0 "Turns = ~D!!!~%" (-> sv-16 flag))
            (set! (-> (the-as (pointer int32) sv-16) 4) 11)
            )
          ;; store turns in DMA
          (set! (-> (the-as (pointer int32) sv-32) 3) (-> sv-16 flag))
          ;; do something with color
          (let* ((f0-7 (- (-> *math-camera* perspective vector 1 y)))
                 (f2-4 (-> (the-as vector sv-32) y))
                 (f4-0 (+ f2-4 (* (-> (the-as (pointer float) sv-48)) f0-7)))
                 (f3-0 256.0)
                 (f1-7 (-> (the-as (pointer float) sv-48)))
                 )
            (if (< (the float (-> *video-parms* screen-sy)) f4-0)
                (set! f3-0 (/ (- (the float (-> *video-parms* screen-sy)) f2-4) f0-7))
                )
            (if (< 128.0 f3-0)
                (set! f3-0 128.0)
                )
            (when (< f3-0 f1-7)
              (let ((v1-55 (/ f3-0 f1-7)))
                (.mov vf1 v1-55)
                )
              (.mul.x.vf vf2 vf2 vf1)
              (.svf (&-> (the-as vector sv-48) quad) vf2)
              )
            )
          ;; inc DMA ptr
          (&+! (-> arg0 base) 48)
          ;; inc chunk size
          (+! s4-0 1)
          ;; if chunk is full
          (when (= s4-0 85)
            (let ((v1-62 (-> arg0 base)))
              (set! (-> arg0 base) s0-0)
              (let* ((a0-8 arg0)
                     (a1-3 (the-as object (-> a0-8 base)))
                     )
                (set!
                 (-> (the-as dma-packet a1-3) dma)
                 (new 'static 'dma-tag :id (dma-tag-id cnt) :qwc (* 3 s4-0))
                 )
                (set! (-> (the-as dma-packet a1-3) vif0) (new 'static 'vif-tag))
                (set!
                 (-> (the-as dma-packet a1-3) vif1)
                 (new 'static 'vif-tag
                      :cmd (vif-cmd unpack-v4-32)
                      :imm (shr (shl (+ (* 3 s5-0) 512) 54) 54)
                      :num (* 3 s4-0)
                      )
                 )
                (set! (-> a0-8 base) (&+ (the-as pointer a1-3) 16))
                )
              (set! (-> arg0 base) v1-62)
              )
            (set! s4-0 0)
            (+! s5-0 85)
            (when (= s5-0 170)
              (let* ((v1-65 arg0)
                     (a0-9 (the-as object (-> v1-65 base)))
                     )
                (set! (-> (the-as dma-packet a0-9) dma) (new 'static 'dma-tag :qwc #x1 :id (dma-tag-id cnt)))
                (set! (-> (the-as dma-packet a0-9) vif0) (new 'static 'vif-tag))
                (set! (-> (the-as dma-packet a0-9) vif1) (new 'static 'vif-tag :imm #x1ff :num #x1 :cmd (vif-cmd unpack-v4-32)))
                (set! (-> v1-65 base) (&+ (the-as pointer a0-9) 16))
                )
              (let* ((v1-66 arg0)
                     (a0-11 (the-as object (-> v1-66 base)))
                     )
                (set! (-> (the-as vector4w a0-11) x) s5-0)
                (set! (-> (the-as vector4w a0-11) y) 0)
                (set! (-> (the-as vector4w a0-11) z) 0)
                (set! (-> (the-as vector4w a0-11) w) 0)
                (set! (-> v1-66 base) (&+ (the-as pointer a0-11) 16))
                )
              (let* ((v1-67 arg0)
                     (a0-13 (the-as object (-> v1-67 base)))
                     )
                (set! (-> (the-as dma-packet a0-13) dma) (new 'static 'dma-tag :id (dma-tag-id cnt)))
                (set! (-> (the-as dma-packet a0-13) vif0) (new 'static 'vif-tag :cmd (vif-cmd mscalf) :msk #x1))
                (set! (-> (the-as dma-packet a0-13) vif1) (new 'static 'vif-tag :cmd (vif-cmd flush) :msk #x1))
                (set! (-> v1-67 base) (&+ (the-as pointer a0-13) 16))
                )
              (set! s5-0 0)
              )
            (set! s0-0 (-> arg0 base))
            (&+! (-> arg0 base) 16)
            )
          (label cfg-21)
          )
        )
      ;; add final in progress chunk, if any
      (cond
        ((zero? s4-0)
         (set! (-> arg0 base) s0-0)
         (nop!)
         0
         )
        (else
         (let ((v1-74 (-> arg0 base)))
           (set! (-> arg0 base) s0-0)
           (let* ((a0-15 arg0)
                  (a1-10 (the-as object (-> a0-15 base)))
                  )
             (set! (-> (the-as dma-packet a1-10) dma) (new 'static 'dma-tag :id (dma-tag-id cnt) :qwc (* 3 s4-0)))
             (set! (-> (the-as dma-packet a1-10) vif0) (new 'static 'vif-tag))
             (set! (-> (the-as dma-packet a1-10) vif1)
                   (new 'static 'vif-tag
                        :cmd (vif-cmd unpack-v4-32)
                        :imm (shr (shl (+ (* 3 s5-0) 512) 54) 54)
                        :num (* 3 s4-0)
                        )
                   )
             (set! (-> a0-15 base) (&+ (the-as pointer a1-10) 16))
             )
           (set! (-> arg0 base) v1-74)
           )
         )
        )
      ;; final dma, if any sprites were dma'd
      (let ((v1-75 (+ s4-0 s5-0)))
        (when (nonzero? v1-75)
          (let* ((a0-17 arg0)
                 (a1-12 (the-as object (-> a0-17 base)))
                 )
            (set! (-> (the-as dma-packet a1-12) dma) (new 'static 'dma-tag :qwc #x1 :id (dma-tag-id cnt)))
            (set! (-> (the-as dma-packet a1-12) vif0) (new 'static 'vif-tag))
            (set! (-> (the-as dma-packet a1-12) vif1) (new 'static 'vif-tag :imm #x1ff :num #x1 :cmd (vif-cmd unpack-v4-32)))
            (set! (-> a0-17 base) (&+ (the-as pointer a1-12) 16))
            )
          (let* ((a0-18 arg0)
                 (a1-14 (the-as object (-> a0-18 base)))
                 )
            (set! (-> (the-as vector4w a1-14) x) v1-75)
            (set! (-> (the-as vector4w a1-14) y) 0)
            (set! (-> (the-as vector4w a1-14) z) 0)
            (set! (-> (the-as vector4w a1-14) w) 0)
            (set! (-> a0-18 base) (&+ (the-as pointer a1-14) 16))
            )
          (let ((v1-77 (the-as object (-> arg0 base))))
            (set! (-> (the-as dma-packet v1-77) dma) (new 'static 'dma-tag :id (dma-tag-id cnt)))
            (set! (-> (the-as dma-packet v1-77) vif0) (new 'static 'vif-tag :cmd (vif-cmd mscalf) :msk #x1))
            (set! (-> (the-as dma-packet v1-77) vif1) (new 'static 'vif-tag :cmd (vif-cmd flush) :msk #x1))
            (set! (-> arg0 base) (&+ (the-as pointer v1-77) 16))
            )
          )
        )
      )
    0
    (none)
    )
  )

